"use strict";(self.webpackChunkbitbom_docs=self.webpackChunkbitbom_docs||[]).push([[3336],{5112:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var s=i(4848),t=i(8453);const r={title:"Roaring Bitmaps",slug:"roaring-bitmaps",description:"Understanding the Roaring Bitmaps data structure and how it works"},a=void 0,o={id:"roaring-bitmaps",title:"Roaring Bitmaps",description:"Understanding the Roaring Bitmaps data structure and how it works",source:"@site/glossary/02_roaring-bitmaps.mdx",sourceDirName:".",slug:"/roaring-bitmaps",permalink:"/glossary/roaring-bitmaps",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Roaring Bitmaps",slug:"roaring-bitmaps",description:"Understanding the Roaring Bitmaps data structure and how it works"},sidebar:"glossary",previous:{title:"Software Bill of Materials (SBOM)",permalink:"/glossary/what-is-an-SBOM"}},l={},c=[{value:"Key Benefits",id:"key-benefits",level:2},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Speed",id:"speed",level:3},{value:"Space Efficiency",id:"space-efficiency",level:3},{value:"Limitations",id:"limitations",level:2},{value:"Best Use Cases",id:"best-use-cases",level:2}];function d(e){const n={a:"a",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://roaringbitmap.org/",children:"Roaring bitmaps"})," are a highly efficient data structure for storing and processing sets of 32-bit integers, offering exceptional compression while maintaining fast operation speeds. They have become the go-to solution for many high-performance systems including Youtube, Microsoft, Netflix, and many others."]}),"\n",(0,s.jsx)(n.h2,{id:"key-benefits",children:"Key Benefits"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Can be hundreds of times faster than traditional compressed bitmaps"}),"\n",(0,s.jsx)(n.li,{children:"Significantly better compression ratios"}),"\n",(0,s.jsx)(n.li,{children:"Maintains fast operations despite compression"}),"\n",(0,s.jsx)(n.li,{children:"Used by major tech companies and databases worldwide"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,s.jsx)(n.h3,{id:"speed",children:"Speed"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Fast set operations (AND, OR, XOR) through optimized algorithms"}),"\n",(0,s.jsx)(n.li,{children:"Quick element lookup through binary search or direct bitmap access"}),"\n",(0,s.jsx)(n.li,{children:"Container-level operations can skip empty ranges"}),"\n",(0,s.jsx)(n.li,{children:"Maintains high performance even with large datasets"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"space-efficiency",children:"Space Efficiency"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Real-world example: Reduced memory usage from 125GB to 300MB in one case"}),"\n",(0,s.jsx)(n.li,{children:"Adapts storage strategy based on data density"}),"\n",(0,s.jsx)(n.li,{children:"No significant speed penalty for compression"}),"\n",(0,s.jsx)(n.li,{children:"Dynamic container conversion based on cardinality"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,s.jsxs)(n.p,{children:['Roaring bitmaps, are extremely efficient, and "Roaring bitmaps are designed to store sets of 32-bit (unsigned) integers. Thus a Roaring bitmap can contain up to ',(0,s.jsx)(n.strong,{children:"4294967296"}),' integers." (',(0,s.jsx)(n.a,{href:"https://github.com/RoaringBitmap/RoaringFormatSpec?tab=readme-ov-file#standard-32-bit-roaring-bitmap",children:"Roaring Bitmap Spec"}),")"]}),"\n",(0,s.jsxs)(n.p,{children:["That means that they are able to store ",(0,s.jsx)(n.strong,{children:"more than 4 billion integers in a single bitmap"}),"."]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"32-bit Integer Restriction"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Designed specifically for 32-bit unsigned integers"}),"\n",(0,s.jsx)(n.li,{children:"Requires mapping other data types to this range"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Memory Overhead"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Small overhead from container management"}),"\n",(0,s.jsx)(n.li,{children:"May not be optimal for very small sets"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Uniform Distribution"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Less effective compression for uniformly distributed data"}),"\n",(0,s.jsx)(n.li,{children:"Traditional bitsets might be better for small, dense sets"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"best-use-cases",children:"Best Use Cases"}),"\n",(0,s.jsx)(n.p,{children:"Roaring bitmaps excel in:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Search engines and databases"}),"\n",(0,s.jsx)(n.li,{children:"Large-scale data analytics"}),"\n",(0,s.jsx)(n.li,{children:"Systems requiring fast set operations"}),"\n",(0,s.jsx)(n.li,{children:"Scenarios with sparse or clustered data"}),"\n",(0,s.jsx)(n.li,{children:"Applications needing both space efficiency and speed"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Roaring bitmaps represent a significant advancement in bitmap technology, offering an rare combination of both space efficiency and speed, making them an excellent choice for modern high-performance systems dealing with large sets of integers."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var s=i(6540);const t={},r=s.createContext(t);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);